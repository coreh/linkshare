/**
 * Build Tailwind CSS for each theme.
 * Reads themes/<name>/input.css, outputs themes/<name>/assets/tailwind.css.
 *
 * Before building, generates a _generated.html file per theme containing all
 * CSS class names that are dynamically constructed at runtime and therefore
 * invisible to Tailwind's source scanner:
 * - theme.toml vars (dark: prefixed versions from getVars auto-mode)
 * - {{dc "dark" "light"}} helper calls (dark: prefixed first-argument classes)
 */
import { readdir, mkdir, unlink } from "fs/promises";
import { join, resolve } from "path";
import { parse as parseTOML } from "smol-toml";
import { Glob } from "bun";

const ROOT = resolve(import.meta.dir, "..");
const THEMES_DIR = join(ROOT, "themes");
const CLI = join(ROOT, "node_modules", ".bin", "tailwindcss");

/** Extract dark:-prefixed classes from theme.toml vars */
function classesFromVars(
  vars: Record<string, Record<string, string>>,
): string[] {
  const darkVars = vars.dark || {};
  const lightVars = vars.light || {};
  const allKeys = new Set([
    ...Object.keys(darkVars),
    ...Object.keys(lightVars),
  ]);

  const classes: string[] = [];
  for (const key of allKeys) {
    const dv = darkVars[key] || "";
    const lv = lightVars[key] || "";

    // Light-mode classes as-is
    if (lv) classes.push(...lv.split(/\s+/).filter(Boolean));

    // Dark-mode classes with dark: prefix (mimics getVars auto-mode logic)
    if (dv) {
      classes.push(
        ...dv
          .split(/\s+/)
          .filter(Boolean)
          .map((c) => `dark:${c}`),
      );
    }
  }
  return classes;
}

/** Extract dark:-prefixed classes from {{dc "dark" "light"}} calls in templates */
async function classesFromTemplates(themeDir: string): Promise<string[]> {
  const classes: string[] = [];
  const dcPattern = /\{\{dc\s+"([^"]+)"\s+"([^"]+)"\}\}/g;

  const glob = new Glob("**/*.html");
  for await (const path of glob.scan({
    cwd: themeDir,
    absolute: true,
    onlyFiles: true,
  })) {
    // Skip generated files and assets
    if (path.includes("_generated.html") || path.includes("/assets/"))
      continue;
    const content = await Bun.file(path).text();
    for (const match of content.matchAll(dcPattern)) {
      const darkClasses = match[1];
      // Add dark:-prefixed versions of the dark argument
      classes.push(
        ...darkClasses
          .split(/\s+/)
          .filter(Boolean)
          .map((c) => `dark:${c}`),
      );
    }
  }
  return classes;
}

/**
 * Generate _generated.html containing all dynamically-constructed class names
 * so Tailwind's scanner picks them up during the build.
 */
async function generateClassesFile(
  themeDir: string,
): Promise<string | null> {
  const classes: string[] = [];

  // 1) Classes from theme.toml vars
  const tomlPath = join(themeDir, "theme.toml");
  const tomlFile = Bun.file(tomlPath);
  if (await tomlFile.exists()) {
    const config = parseTOML(await tomlFile.text()) as Record<
      string,
      unknown
    >;
    const vars = config.vars as
      | Record<string, Record<string, string>>
      | undefined;
    if (vars) classes.push(...classesFromVars(vars));
  }

  // 2) Classes from {{dc}} calls in templates
  classes.push(...(await classesFromTemplates(themeDir)));

  if (classes.length === 0) return null;

  // Deduplicate
  const unique = [...new Set(classes)];

  const outPath = join(themeDir, "_generated.html");
  const html = `<!-- Generated by build-css.ts — do not edit -->\n<div class="${unique.join(" ")}"></div>\n`;
  await Bun.write(outPath, html);
  return outPath;
}

const entries = await readdir(THEMES_DIR, { withFileTypes: true });
let built = 0;
const generatedFiles: string[] = [];

for (const entry of entries) {
  if (!entry.isDirectory() || entry.name.startsWith(".")) continue;

  const themeDir = join(THEMES_DIR, entry.name);
  const inputCss = join(themeDir, "input.css");
  const assetsDir = join(themeDir, "assets");
  const outputCss = join(assetsDir, "tailwind.css");

  const inputFile = Bun.file(inputCss);
  if (!(await inputFile.exists())) continue;

  // Generate scannable classes file before building
  const genFile = await generateClassesFile(themeDir);
  if (genFile) generatedFiles.push(genFile);

  await mkdir(assetsDir, { recursive: true });

  const proc = Bun.spawn(
    [CLI, "-i", inputCss, "-o", outputCss],
    { cwd: ROOT, stdout: "ignore", stderr: "pipe" },
  );
  const exitCode = await proc.exited;

  if (exitCode !== 0) {
    const stderr = await new Response(proc.stderr).text();
    console.error(`Failed to build ${entry.name}:\n${stderr}`);
    process.exit(1);
  }

  built++;
  console.log(`Built ${entry.name} → assets/tailwind.css`);
}

// Clean up generated files
for (const f of generatedFiles) {
  await unlink(f);
}

console.log(`Built ${built} theme(s)`);
