<!DOCTYPE html>
<html lang="{{locale}}" dir="{{dir}}" class="{{dc "dark" ""}}">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>{{title}} - Password Required</title>
  <script src="https://cdn.tailwindcss.com?plugins=forms"></script>
  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          colors: {
            accent: {
              50: 'var(--c-50)',
              100: 'var(--c-100)',
              200: 'var(--c-200)',
              300: 'var(--c-300)',
              400: 'var(--c-400)',
              500: 'var(--c-500)',
              600: 'var(--c-600)',
              700: 'var(--c-700)',
              800: 'var(--c-800)',
              900: 'var(--c-900)',
              950: 'var(--c-950)',
            }
          }
        }
      }
    }
  </script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Mountains+of+Christmas:wght@400;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --c-50: #fef2f2;
      --c-100: #fee2e2;
      --c-200: #fecaca;
      --c-300: #fca5a5;
      --c-400: #f87171;
      --c-500: #ef4444;
      --c-600: #dc2626;
      --c-700: #b91c1c;
      --c-800: #991b1b;
      --c-900: #7f1d1d;
      --c-950: #450a0a;
    }
    body {
      font-family: 'Mountains of Christmas', cursive;
      background-color: {{dc background_color_dark background_color_light}};
    }
    {{{theme_css}}}
  </style>
  {{#if auto_dark}}
  <script>
    if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
      document.documentElement.classList.add('dark')
    } else {
      document.documentElement.classList.remove('dark')
    }
  </script>
  {{/if}}
</head>
<body class="{{dc "bg-red-950 text-red-100" "bg-red-50 text-red-900"}} min-h-screen flex items-center justify-center">
  <div class="w-full max-w-md px-4">
    <div class="{{card_static}} rounded-lg border p-8">
      <div class="text-center mb-6">
        <div class="text-6xl mb-4">üéÅ</div>
        <h1 class="text-3xl font-bold mb-2">{{title}}</h1>
        <p class="{{muted}}">{{t "This content is password protected"}}</p>
      </div>

      <form method="POST" action="{{path}}" class="space-y-4">
        <div>
          <label for="password" class="block text-sm font-medium mb-2">
            {{t "Password"}}
          </label>
          <input
            type="password"
            id="password"
            name="password"
            required
            autofocus
            class="{{input}} w-full px-4 py-2 rounded-lg border focus:ring-2 focus:ring-accent-500 focus:border-transparent"
            placeholder="{{t "Enter password..."}}"
          >
        </div>

        {{#if error}}
        <div class="bg-red-500/20 border border-red-500/50 text-red-200 px-4 py-3 rounded-lg text-sm">
          {{error}}
        </div>
        {{/if}}

        <button
          type="submit"
          class="w-full bg-accent-600 {{hover_text}} text-white font-medium py-2 px-4 rounded-lg hover:bg-accent-700 transition-colors"
        >
          {{t "Unlock üîì"}}
        </button>
      </form>

      {{#if parent.path}}
      <div class="mt-6 text-center">
        <a href="{{parent.path}}" class="{{muted}} {{hover_text}} text-sm">
          {{t "‚Üê Go back"}}
        </a>
      </div>
      {{/if}}
    </div>
  </div>

  <canvas class="ls-snow-canvas" id="snowCanvas"></canvas>
  <script>
  (function() {
    var canvas = document.getElementById('snowCanvas');
    var ctx = canvas.getContext('2d');
    var W, H, N = 120, PR = 6, MP = 28, TAPER = 8;
    var flakes = [], surfs = [], wind = 0, wt = 0, fc = 0, seeded = false;

    function sz() { W = canvas.width = innerWidth; H = canvas.height = innerHeight; }
    sz();
    addEventListener('resize', function() { sz(); scan(); });

    function taperAt(col, len) {
      var edge = Math.min(col, len - 1 - col);
      return Math.min(1, edge / TAPER);
    }

    function scan() {
      var sy = scrollY, old = surfs;
      surfs = [];
      var els = document.querySelectorAll(
        '[class*="rounded"][class*="border"],[class*="border"][class*="rounded"],[data-embed-container]'
      );
      for (var i = 0; i < els.length; i++) {
        var r = els[i].getBoundingClientRect();
        if (r.width < 40 || r.height < 15) continue;
        var dt = Math.round(r.top + sy), l = Math.round(r.left), ri = Math.round(r.right);
        var cols = Math.ceil((ri - l) / PR), pile = null;
        for (var j = 0; j < old.length; j++) {
          if (Math.abs(old[j].t - dt) < 8 && Math.abs(old[j].l - l) < 8 && old[j].p.length === cols) {
            pile = old[j].p; old.splice(j, 1); break;
          }
        }
        if (!pile) pile = new Float32Array(cols);
        surfs.push({ l: l, r: ri, t: dt, p: pile });
      }
      if (!seeded && surfs.length > 0) {
        seeded = true;
        for (var si = 0; si < surfs.length; si++) {
          var sp = surfs[si].p;
          for (var k = 0; k < sp.length; k++)
            sp[k] = (1 + Math.random() * 2 + Math.sin(k * 0.3)) * taperAt(k, sp.length);
          for (var pass = 0; pass < 3; pass++)
            for (var k = 1; k < sp.length - 1; k++)
              sp[k] = (sp[k - 1] + sp[k] * 2 + sp[k + 1]) / 4;
        }
      }
    }

    function mk(full) {
      return {
        x: Math.random() * W, y: full ? Math.random() * H : -Math.random() * 40 - 5,
        r: Math.random() * 2.5 + 0.8, sp: Math.random() * 1.2 + 0.4,
        wb: Math.random() * 6.28, ws: Math.random() * 0.02 + 0.005,
        o: Math.random() * 0.5 + 0.3
      };
    }

    for (var i = 0; i < N; i++) flakes.push(mk(true));
    scan();

    function frame() {
      ctx.clearRect(0, 0, W, H);
      var sy = scrollY;
      if (++fc % 120 === 0) scan();
      wt += (Math.random() - 0.5) * 0.02;
      wt = Math.max(-0.4, Math.min(0.4, wt));
      wind += (wt - wind) * 0.01;

      for (var i = 0; i < N; i++) {
        var f = flakes[i];
        f.wb += f.ws;
        f.x += Math.sin(f.wb) * 0.5 + wind;
        f.y += f.sp;
        var dy = f.y + sy, hit = false;
        for (var j = 0; j < surfs.length; j++) {
          var s = surfs[j];
          if (f.x >= s.l && f.x < s.r) {
            var col = Math.floor((f.x - s.l) / PR);
            if (col >= 0 && col < s.p.length) {
              var tp = taperAt(col, s.p.length);
              var cap = MP * tp;
              if (dy >= s.t - s.p[col] && s.p[col] < cap) {
                var a = (0.4 + Math.random() * 0.3) * tp;
                s.p[col] = Math.min(cap, s.p[col] + a);
                if (col > 0) s.p[col - 1] = Math.min(MP * taperAt(col - 1, s.p.length), s.p[col - 1] + a * 0.3);
                if (col < s.p.length - 1) s.p[col + 1] = Math.min(MP * taperAt(col + 1, s.p.length), s.p[col + 1] + a * 0.3);
                hit = true; break;
              }
            }
          }
        }
        if (hit || f.y > H + 5) { flakes[i] = mk(false); continue; }
        if (f.x > W + 5) f.x = -5;
        if (f.x < -5) f.x = W + 5;
        ctx.beginPath();
        ctx.arc(f.x, f.y, f.r, 0, 6.28);
        ctx.fillStyle = 'rgba(255,255,255,' + f.o + ')';
        ctx.fill();
      }

      for (var j = 0; j < surfs.length; j++) {
        var p = surfs[j].p;
        for (var k = 1; k < p.length - 1; k++)
          p[k] += ((p[k - 1] + p[k + 1]) / 2 - p[k]) * 0.03;
      }

      for (var j = 0; j < surfs.length; j++) {
        var s = surfs[j], by = s.t - sy;
        if (by < -MP - 5 || by > H + 5) continue;
        var any = false;
        for (var k = 0; k < s.p.length; k++) { if (s.p[k] > 0.3) { any = true; break; } }
        if (!any) continue;
        ctx.beginPath();
        ctx.moveTo(s.l, by);
        for (var k = 0; k < s.p.length; k++) {
          var px = s.l + (k + 0.5) * PR, py = by - s.p[k];
          if (k === 0) ctx.lineTo(px, py);
          else {
            var ox = s.l + (k - 0.5) * PR, oy = by - s.p[k - 1];
            ctx.quadraticCurveTo(ox, oy, (ox + px) / 2, (oy + py) / 2);
          }
        }
        ctx.lineTo(s.l + (s.p.length - 0.5) * PR, by - s.p[s.p.length - 1]);
        ctx.lineTo(s.r, by);
        ctx.closePath();
        ctx.fillStyle = 'rgba(255,255,255,0.85)';
        ctx.fill();
        ctx.strokeStyle = 'rgba(200,220,255,0.25)';
        ctx.lineWidth = 0.5;
        ctx.stroke();
      }

      requestAnimationFrame(frame);
    }
    frame();
  })();
  </script>
</body>
</html>
